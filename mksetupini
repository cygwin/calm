#!/usr/bin/env python3
#
# Copyright (c) 2015 Jon Turney
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

#
# mksetupini
#
# Make a setup.ini file from a collection of tarfile and setup.hints
#

import argparse
import textwrap
import time
import re
import logging
import os
import sys
from distutils.version import LooseVersion
from collections import defaultdict

import common_constants
import package

#
#
#
#
#

def main(args):
    # build package list
    packages = package.read_packages(args.rel_area, args.arch)

    #
    # validate the package database
    #
    for p in sorted(packages.keys()):
        # all packages listed in requires must exist
        if 'requires' in packages[p].hints:
            for r in packages[p].hints['requires'].split():
                if r not in packages:
                    logging.error("package '%s' requires nonexistent package '%s'" % (p, r))

        # if external-source is used, the package must exist
        if 'external-source' in packages[p].hints:
            e = packages[p].hints['external-source']
            if e not in packages:
                logging.error("package '%s' refers to nonexistent external-source '%s'" % (p, e))

        packages[p].vermap = defaultdict(defaultdict)
        has_install = False

        for t in packages[p].tars:
            # categorize each tarfile as either 'source' or 'install'
            if re.search(r'-src\.tar', t):
                category = 'source'
            else:
                category = 'install'
                has_install = True

            # extract just the version part from tar filename
            v = re.sub(r'^' + re.escape(p) + '-', '', t)
            v = re.sub(r'(-src|)\.tar\.(xz|bz2|gz)$', '', v)

            # store tarfile corresponding to this version and category
            packages[p].vermap[v][category] = t

        levels = [ 'curr', 'prev' ]
        packages[p].stability = defaultdict()

        # sort in order from highest to lowest version
        for v in sorted(packages[p].vermap.keys(), reverse=True):
            required_categories = []

            # a source tarfile must exist for every version, unless
            # - the install tarfile is empty, or
            # - this package is external-source
            if 'external-source' not in packages[p].hints:
                if 'install' in packages[p].vermap[v]:
                    if not package.tarfile_is_empty(os.path.join(args.rel_area, args.arch, packages[p].path, packages[p].vermap[v]['install'])):
                        required_categories.append('source')

            # similarly, we should verify that each version has an install
            # tarfile, unless this is a source-only package.  Unfortunately, the
            # current data model doesn't clearly identify those.  For the
            # moment, if we have seen at least one install tarfile, assume we
            # aren't a source-only package.
            if has_install:
                required_categories.append('install')

            for c in required_categories:
                if c not in packages[p].vermap[v]:
                    logging.error("package '%s' version '%s' is missing %s tarfile" % (p, v, c))

            # assign a version to each stability level
            if len(levels) > 0:
                packages[p].stability[levels.pop(0)] = v
            else:
                # XXX: versions which don't correspond to any stability level
                # should be reported, we might want to remove them at some point
#                logging.error("package '%s' has no levels left for version '%s'" % (p, v))
                pass

        # XXX: all stability levels must exist?

    #
    # write setup.ini
    #
    with open(args.inifile, 'w') as f:
        # write setup.ini header
        print(textwrap.dedent('''\
        # This file is automatically generated.  If you edit it, your
        # edits will be discarded next time the file is generated.
        # See http://cygwin.com/setup.html for details.
        #'''), file=f)

        if args.release:
              print("release: %s" % args.release, file=f)
        print("arch: %s" % args.arch, file=f)
        print("setup-timestamp: %d" % time.time(), file=f)
        if args.setup_version:
              print("setup-version: %s" % args.setup_version, file=f)

        # for each package
        for p in sorted(packages.keys(), key=package.sort_key):
            # do nothing if 'skip'
            if 'skip' in packages[p].hints:
                continue

            # write package data
            print("\n@ %s" % p, file=f)

            # for historical reasons, we adjust sdesc slightly:
            #
            # - strip anything up to and including first ':'
            # - capitalize first letter
            #
            # these are both bad ideas, due to sdesc's which start with a
            # lower-case command name, or contain perl or ruby module names like
            # 'Net::HTTP'
            sdesc = packages[p].hints['sdesc']
            if ':' in sdesc:
                sdesc = sdesc.split(':', 1)[1]
            sdesc = sdesc[0].upper() + sdesc[1:]
            print("sdesc: %s" % sdesc, file=f)

            if 'ldesc' in packages[p].hints:
                print("ldesc: %s" % packages[p].hints['ldesc'], file=f)

            print("category: %s" % packages[p].hints['category'], file=f)

            if 'requires' in packages[p].hints:
                print("requires: %s" % packages[p].hints['requires'], file=f)

            # write tarfile lines for each stability level
            for level in [ 'curr', 'test', 'prev' ]:
                if level in packages[p].stability:
                    version = packages[p].stability[level]
                    if level != 'curr':
                        print("[%s]" % level, file=f)
                    print("version: %s" % version, file=f)
                    for category in ['install', 'source']:
                        if category in packages[p].vermap[version]:
                            t = packages[p].vermap[version][category]
                            fn = os.path.join(args.arch, packages[p].path, t)
                            sha512 = packages[p].tars[t]['sha512']
                            size = packages[p].tars[t]['size']
                            print("%s: %s %d %s" % (category, fn, size, sha512), file=f)

                    # XXX: follow external-source

            if 'message' in packages[p].hints:
                print("message: %s" % packages[p].hints['message'], file=f)

if __name__ == "__main__":
    relarea_default = common_constants.FTP

    parser = argparse.ArgumentParser(description='Make setup.ini')
    parser.add_argument('--arch', action='store', required=True, choices=common_constants.ARCHES)
    parser.add_argument('--inifile', '-u', action='store', help='output filename', required=True)
    parser.add_argument('--release', action='store', help='value for setup-release key (default: cygwin)', default='cygwin')
    parser.add_argument('--releasearea', action='store', metavar='DIR', help="release directory (default: " + relarea_default + ")", default=relarea_default, dest='rel_area')
    parser.add_argument('--setup-version' , action='store', metavar='VERSION', help='value for setup-version key')
    parser.add_argument('-v', '--verbose', action='count', dest = 'verbose', help='verbose output')
    (args) = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.INFO)

    logging.basicConfig(format=os.path.basename(sys.argv[0])+': %(message)s')

    main(args)
