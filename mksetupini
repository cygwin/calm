#!/usr/bin/env python3
#
# Copyright (c) 2015 Jon Turney
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

#
# mksetupini
#
# Make a setup.ini file from a collection of tarfile and setup.hints
#

import argparse
import textwrap
import time
import re
import logging
import os
import sys
from distutils.version import LooseVersion
from collections import defaultdict

import common_constants
import package

#
#
#
class LooserVersion(LooseVersion):
    #override
    def _cmp(self, other):
        try:
            return super(LooserVersion, self)._cmp(other)
        except TypeError:
            # When unorderable, compare the version strings instead
            if isinstance(other, str):
                other = LooseVersion(other)
            if self.vstring == other.vstring:
                return 0
            if self.vstring < other.vstring:
                return -1
            if self.vstring > other.vstring:
                return 1

#
#
#

def main(args):
    # build package list
    packages = package.read_packages(args.rel_area, args.arch)

    # validate the package set
    if not validate_packages(args, packages):
        return

    # write setup.ini
    write_setup_ini(args, packages);

#
# validate the package database
#
def validate_packages(args, packages):
    error = False

    for p in sorted(packages.keys()):
        # all packages listed in requires must exist
        if 'requires' in packages[p].hints:
            for r in packages[p].hints['requires'].split():
                if r not in packages:
                    logging.error("package '%s' requires nonexistent package '%s'" % (p, r))
                    error = True

        # XXX: a package appearing it it's own requires should be disallowed

        # if external-source is used, the package must exist
        if 'external-source' in packages[p].hints:
            e = packages[p].hints['external-source']
            if e not in packages:
                logging.error("package '%s' refers to nonexistent external-source '%s'" % (p, e))
                error = True

        packages[p].vermap = defaultdict(defaultdict)
        has_install = False
        is_empty = {}

        for t in packages[p].tars:
            # categorize each tarfile as either 'source' or 'install'
            if re.search(r'-src\.tar', t):
                category = 'source'
            else:
                category = 'install'
                has_install = True

                # check if install package is empty
                is_empty[t] = package.tarfile_is_empty(os.path.join(args.rel_area, args.arch, packages[p].path, t))

            # extract just the version part from tar filename
            v = re.sub(r'^' + re.escape(p) + '-', '', t)
            v = re.sub(r'(-src|)\.tar\.(xz|bz2|gz)$', '', v)

            # store tarfile corresponding to this version and category
            packages[p].vermap[v][category] = t

        # verify the versions specified for stability level exist
        levels = ['test', 'curr', 'prev']
        for l in levels:
            if l in packages[p].hints:
                # check that version exists
                v = packages[p].hints[l]
                if v not in packages[p].vermap.keys():
                    logging.error("package '%s' stability '%s' selects non-existent version '%s'" % (p, l, v))
                    error = True

        # assign a version to each stability level
        packages[p].stability = defaultdict()

        # sort in order from highest to lowest version
        for v in sorted(packages[p].vermap.keys(), key=lambda v:LooserVersion(v), reverse=True):
            level_found = False

            while True:
                # no stability levels left
                if len(levels) == 0:
                    # XXX: versions which don't correspond to any stability level
                    # should be reported, we might want to remove them at some point
                    logging.info("package '%s' has no stability levels left for version '%s'" % (p, v))
                    break

                l = levels[0]

                # if current stability level has an override
                if l in packages[p].hints:
                    # if we haven't reached that version yet
                    if v != packages[p].hints[l]:
                        break
                    else:
                        logging.info("package '%s' stability '%s' override to version '%s'" % (p, l, v))
                else:
                    # level 'test' must be assigned by override
                    if l == 'test':
                        levels.remove(l)
                        # go around again to check for override at the new level
                        continue

                level_found = True
                logging.info("package '%s' stability '%s' assigned version '%s'" % (p, l, v))
                break

            if not level_found:
                continue

            # assign version to level
            packages[p].stability[l] = v
            # and remove from list of unallocated levels
            levels.remove(l)

        # verify that versions have files
        for v in sorted(packages[p].vermap.keys(), key=lambda v:LooserVersion(v), reverse=True):
            required_categories = []

            # a source tarfile must exist for every version, unless
            # - the install tarfile is empty, or
            # - this package is external-source
            if 'external-source' not in packages[p].hints:
                if 'install' in packages[p].vermap[v]:
                    if not is_empty[packages[p].vermap[v]['install']]:
                        required_categories.append('source')

            # XXX: actually we should verify that a source tarfile must exist
            # for every install tarfile version, but it may be either in this
            # package or in the external-source package...

            # similarly, we should verify that each version has an install
            # tarfile, unless this is a source-only package.  Unfortunately, the
            # current data model doesn't clearly identify those.  For the
            # moment, if we have seen at least one install tarfile, assume we
            # aren't a source-only package.
            if has_install:
                required_categories.append('install')

            for c in required_categories:
                if c not in packages[p].vermap[v]:
#                    logging.error("package '%s' version '%s' is missing %s tarfile" % (p, v, c))
#                    error = True
                    pass

        # for historical reasons, add cygwin to requires if not already present,
        # the package is not source-only, not empty, not only contains symlinks,
        # and not on the list to avoid doing this for
        # (this approximates what 'autodep' did)
        if has_install and (not all(is_empty.values())) and (p not in ['base-cygwin', 'gcc4-core', 'gcc4-g++']):
            requires = packages[p].hints.get('requires', '')

            if not re.search(r'\bcygwin\b', requires):
                if len(requires) > 0:
                    requires = requires + ' '
                packages[p].hints['requires'] = requires + 'cygwin'

        # if the package has no install tarfiles (i.e. is source only), mark it
        # as 'skip' (which really means 'source-only' at the moment)
        if not has_install and 'skip' not in packages[p].hints:
            packages[p].hints['skip'] = ''

        # XXX: hint can override the version at a stability level
        # XXX: all stability levels must exist?

    return not error

#
# write setup.ini
#
def write_setup_ini(args, packages):

    with open(args.inifile, 'w') as f:
        # write setup.ini header
        print(textwrap.dedent('''\
        # This file is automatically generated.  If you edit it, your
        # edits will be discarded next time the file is generated.
        # See http://cygwin.com/setup.html for details.
        #'''), file=f)

        if args.release:
              print("release: %s" % args.release, file=f)
        print("arch: %s" % args.arch, file=f)
        print("setup-timestamp: %d" % time.time(), file=f)
        if args.setup_version:
              print("setup-version: %s" % args.setup_version, file=f)

        # for each package
        for p in sorted(packages.keys(), key=package.sort_key):
            # do nothing if 'skip'
            if 'skip' in packages[p].hints:
                continue

            # write package data
            print("\n@ %s" % p, file=f)

            # for historical reasons, we adjust sdesc slightly:
            #
            # - strip anything up to and including first ':'
            # - capitalize first letter
            # whilst preserving any leading quote
            #
            # these are both bad ideas, due to sdesc's which start with a
            # lower-case command name, or contain perl or ruby module names like
            # 'Net::HTTP'
            sdesc = packages[p].hints['sdesc']
            sdesc = re.sub('^("?)(.*?)("?)$', r'\2', sdesc)
            if ':' in sdesc:
                sdesc = re.sub(r'^[^:]+:\s*', '', sdesc)
            sdesc = '"' + upper_first_character(sdesc) + '"'
            print("sdesc: %s" % sdesc, file=f)

            if 'ldesc' in packages[p].hints:
                print("ldesc: %s" % packages[p].hints['ldesc'], file=f)

            # for historical reasons, category names must start with a capital
            # letter
            category = ' '.join(map(upper_first_character, packages[p].hints['category'].split()))
            print("category: %s" % category, file=f)

            if 'requires' in packages[p].hints:
                # for historical reasons, empty requires are suppressed
                requires = packages[p].hints['requires']
                if requires:
                    print("requires: %s" % requires, file=f)

            # write tarfile lines for each stability level
            for level in [ 'curr', 'prev', 'test' ]:
                if level in packages[p].stability:
                    version = packages[p].stability[level]
                    if level != 'curr':
                        print("[%s]" % level, file=f)
                    print("version: %s" % version, file=f)

                    if 'install' in packages[p].vermap[version]:
                        t = packages[p].vermap[version]['install']
                        tar_line('install', args.arch, packages[p], t, f)

                    # look for corresponding source in this package first
                    if 'source' in packages[p].vermap[version]:
                        t = packages[p].vermap[version]['source']
                        tar_line('source', args.arch, packages[p], t, f)
                    # if that doesn't exist, follow external-source
                    elif 'external-source' in packages[p].hints:
                        s = packages[p].hints['external-source']
                        t = packages[s].vermap[version]['source']
                        tar_line('source', args.arch, packages[s], t, f)

            if 'message' in packages[p].hints:
                print("message: %s" % packages[p].hints['message'], file=f)

def tar_line(category, arch, p, t, f):
    fn = os.path.join(arch, p.path, t)
    sha512 = p.tars[t]['sha512']
    size = p.tars[t]['size']
    print("%s: %s %d %s" % (category, fn, size, sha512), file=f)

# change the first character of a string to upper case, without altering the
# rest
def upper_first_character(s):
    return s[:1].upper() + s[1:]

if __name__ == "__main__":
    relarea_default = common_constants.FTP

    parser = argparse.ArgumentParser(description='Make setup.ini')
    parser.add_argument('--arch', action='store', required=True, choices=common_constants.ARCHES)
    parser.add_argument('--inifile', '-u', action='store', help='output filename', required=True)
    parser.add_argument('--release', action='store', help='value for setup-release key (default: cygwin)', default='cygwin')
    parser.add_argument('--releasearea', action='store', metavar='DIR', help="release directory (default: " + relarea_default + ")", default=relarea_default, dest='rel_area')
    parser.add_argument('--setup-version' , action='store', metavar='VERSION', help='value for setup-version key')
    parser.add_argument('-v', '--verbose', action='count', dest = 'verbose', help='verbose output')
    (args) = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.INFO)

    logging.basicConfig(format=os.path.basename(sys.argv[0])+': %(message)s')

    main(args)
