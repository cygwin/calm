#!/usr/bin/env python3
#
# Copyright (c) 2015 Jon Turney
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

#
# check maintainer upload directories for files to move to release area
#
# - only process packages for which we are listed as a maintainer
# - only move things with an mtime earlier than the mtime of the !ready file
# - validate the syntax of the setup.ini file before moving anything
# - note if package file already exists in release area with identical contents
# - error if package file already exist in release area with different contents
# - remove !ready file
# - send a report on what we did to the maintainer and project leads
#

from collections import defaultdict
import argparse
import filecmp
import logging
import os
import re
import sys

import buffering_smtp_handler
import common_constants
import hint
import maintainers
import package


#
#
#

def scan(m, arch, args):
    pkgre = '|'.join([re.escape(p) for p in m.pkgs])

    basedir = os.path.join(m.homedir(), arch)
    releasedir = os.path.join(args.rel_area, arch)

    packages = defaultdict(package.Package)
    move = defaultdict(list)
    readys = []
    sums = defaultdict(list)
    error = False
    mtime = 0

    # note mtime of !ready file
    for ready in [os.path.join(basedir, '!ready'), os.path.join(basedir, 'release', '!ready')]:
        if os.path.exists(ready):
            mtime = os.path.getmtime(ready)
            logging.info('processing files with mtime older than %d' % (mtime))
            readys.append(ready)

    # scan package directories
    for (dirpath, subdirs, files) in os.walk(os.path.join(basedir, 'release')):
        p = os.path.relpath(dirpath, basedir)

        # skip uninteresting directories
        if (not files) or (p == 'release'):
            continue

        logging.info('reading uploads from %s' % dirpath)

        # It really only makes sense for !ready to be in the basedir, or
        # basedir/release, but historically we have accepted it anywhere, which
        # affected all files thereafter in some unspecified directory traversal.
        if '!ready' in files:
            logging.error("!ready at %s not supported, ignored" % p)
            files.remove('!ready')

        # only process packages for which we are listed as a maintainer
        if not re.search(pkgre, os.path.basename(dirpath)):
            logging.warn("%s is not in the package list for this maintainer" % os.path.basename(dirpath))
            continue

        # ensure sha512.sum exists
        # XXX: either we make read_package able to calculate sh512 sum when
        # sha512.sum doesn't exist, or we make sure shs512.sum exists.  Not
        # sure which is the better approach.
        if 'sha512.sum' not in files:
            logging.info('generating sha512.sum')
            os.system("cd '%s' ; sha512sum * >sha512.sum" % os.path.join(dirpath))
            files.append('sha512.sum')

        # filter out files we don't need to consider
        for f in sorted(files):
            fn = os.path.join(basedir, p, f)
            logging.info("processing %s" % fn)

            # ignore !packages (which we no longer use)
            # ignore !mail and !email (which we have already read)
            if f == '!packages' or f == '!mail' or f == ' !email':
                files.remove(f)
                continue

            if f == 'sha512.sum':
                sums[p].append(fn)
                continue

            # only process files newer than !ready
            if os.path.getmtime(fn) > mtime:
                if mtime == 0:
                    logging.warn("ignoring %s as there is no !ready" % f)
                else:
                    logging.warn("ignoring %s as it is newer than !ready" % f)
                files.remove(f)
                continue

            if f.startswith('-'):
                logging.error("file deletion request %s not implemented yet" % f)
                files.remove(f)
            else:
                dest = os.path.join(releasedir, p, f)
                if os.path.isfile(dest):
                    if filecmp.cmp(dest, fn, shallow=False):
                        logging.warn("identical %s already in release area, ignoring" % f)
                    else:
                        logging.error("different %s already in release area" % f)
                        error = True
                else:
                    move[p].append(f)

        # read and validate package
        if files:
            # strict means we consider warnings as fatal for upload
            if package.read_package(packages, basedir, dirpath, files, strict=True):
                error = True

    # remove all the !ready files
    for f in readys:
        logging.info("rm %s", f)
        if not args.dryrun:
            os.unlink(f)

    # only move something if there were no errors
    if not error:
        for p in move:
            logging.info("mkdir %s" % os.path.join(releasedir, p))
            if not args.dryrun:
                os.makedirs(os.path.join(releasedir, p), exist_ok=True)
            for f in move[p]:
                logging.info("move %s to %s" % (os.path.join(basedir, p, f), os.path.join(releasedir, p, f)))
                if not args.dryrun:
                    os.rename(os.path.join(basedir, p, f), os.path.join(releasedir, p, f))

            # Remove shs512.sum file in upload directory
            for f in sums[p]:
                logging.info("rm %s", f)
                if not args.dryrun:
                    os.unlink(f)

            # Update sha512.sum file in target directory
            #
            # (this means that upset can use that file unconditionally,
            # rather than having to have a special case to generate the hash
            # itself for when that file hasn't yet been created by
            # sourceware.org scripts)
            if not args.dryrun:
                os.system("cd '%s' ; sha512sum * >sha512.sum" % os.path.join(releasedir, p))


#
#
#

def main(args):
    # create maintainer list
    mlist = {}
    mlist = maintainers.Maintainer.add_directories(mlist, args.homedir)
    mlist = maintainers.Maintainer.add_packages(mlist, args.pkglist, args.orphanmaint)

    for arch in common_constants.ARCHES:
        for name in sorted(mlist.keys()):
            m = mlist[name]

            if args.email:
                handler = buffering_smtp_handler.BufferingSMTPHandler(
                    mailhost='allegra',  # 'localhost',
                    fromaddr='cygwin-no-reply@cygwin.com',
                    toaddrs=args.email + m.email,
                    subject="upset messages",
                    logging_format='%(message)s')
                logging.getLogger().addHandler(handler)

            scan(m, arch, args)

            if args.email:
                handler.close()
                logging.getLogger().removeHandler(handler)


#
#
#

if __name__ == "__main__":
    homedir_default = common_constants.HOMEDIR
    orphanmaint_default = common_constants.ORPHANMAINT
    pkglist_default = common_constants.PKGMAINT
    relarea_default = common_constants.FTP

    parser = argparse.ArgumentParser(description='Move files from maintainer upload directories to release area')
    parser.add_argument('--email', action='store', dest='email', nargs='?', const=common_constants.EMAILS, help='email output to maintainer and ADDRS (default: ' + common_constants.EMAILS + ')', metavar='ADDRS')
    parser.add_argument('--homedir', action='store', metavar='DIR', help="maintainer home directory (default: " + homedir_default + ")", default=homedir_default)
    parser.add_argument('--orphanmaint', action='store', metavar='NAMES', help="orphan package maintainers (default: '" + orphanmaint_default + "')", default=orphanmaint_default)
    parser.add_argument('--pkglist', action='store', metavar='FILE', help="package maintainer list (default: " + pkglist_default + ")", default=pkglist_default)
    parser.add_argument('--releasearea', action='store', metavar='DIR', help="release directory (default: " + relarea_default + ")", default=relarea_default, dest='rel_area')
    parser.add_argument('-n', '--dry-run', action='store_true', dest='dryrun', help="don't do anything")
    parser.add_argument('-v', '--verbose', action='count', dest='verbose', help='verbose output')
    (args) = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.INFO)

    logging.basicConfig(format=os.path.basename(sys.argv[0])+': %(message)s')

    if args.email:
        args.email = args.email.split(',')

    main(args)
