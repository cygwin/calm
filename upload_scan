#!/usr/bin/env python3
#
# check maintainer upload directories for files to move to release area
#
# - only process packages for which we are listed as a maintainer
# - only move things with an mtime earlier than the mtime of the !ready file
# - validate the syntax of the setup.ini file before moving anything
# - note if package file already exists in release area with identical contents
# - error if package file already exist in release area with different contents
# - remove !ready file
# - send a report on what we did to the maintainer and project leads
#
# XXX: sha512.sum ???

import os
import re
import filecmp
import argparse
from collections import defaultdict
import logging
import buffering_smtp_handler

import maintainers
import cygwin

#
#
#

dryrun = False
email = []

#
#
#

def scan(m, arch):
    pkgre = '|'.join(m.pkgs)

    basedir = os.path.join(m.homedir(), arch)
    releasedir = os.path.join(cygwin.FTP, arch)

    move = defaultdict(list)
    readys = []
    error = False
    mtime = 0

    for (dir, subdirs, files) in os.walk(basedir):
        p = os.path.relpath(dir, basedir)

        for f in sorted(files):
            fn = os.path.join(basedir, p, f)
            logging.info("processing %s" % fn)

            if f == '!ready':
                mtime = os.path.getmtime(fn)
                readys.append(fn)
                continue
            elif f.startswith('!'):
                continue
            elif f == 'setup.hint':
                if setup_hint_validate(fn):
                    move[p].append(f)
                else:
                    error = True
                continue

            if os.path.getmtime(fn) > mtime:
                if mtime == 0:
                    logging.warn("ignoring %s as there is no !ready" % f)
                else:
                    logging.warn("ignoring %s as it is newer than !ready" % f)
                continue

            if not re.search(pkgre, f):
                logging.warn("%s is not in the package list for this maintainer" % f)
                continue

            if f.startswith('-'):
                logging.error("file deletion request %s not implemented yet" % f)
            elif re.search('.tar.*$', f):
                dest = os.path.join(releasedir, p, f)
                if os.path.isfile(dest):
                    if filecmp.cmp(dest, fn, shallow=False):
                        logging.warn("identical %s already in release area, ignoring" % f)
                    else:
                        logging.error("different %s already in release area" % f)
                        error = True
                else:
                    move[p].append(f)
            else:
                logging.error("unexpected file %s" % f)

    for f in readys:
        logging.info("rm", f)
        if not dryrun:
            os.unlink(f)

    if not error:
        if len(move) > 0:
            for dir in move.keys():
                logging.info("mkdir", os.path.join(releasedir, p))
                if not dryrun:
                    os.makedirs(os.path.join(releasedir, p), exist_ok=True)
                for f in move[dir]:
                    logging.info("move", os.path.join(basedir, p, f), os.path.join(releasedir, p, f))
                    if not dryrun:
                        os.rename(os.path.join(basedir, p, f), os.path.join(releasedir, p, f))

    # XXX: should update md5.sum and sha512.sum in target directory, if it
    # wasn't part of the upload

#
#
#

def setup_hint_validate(fn):
    # XXX: should validate that setup.hint is UTF-8 encoded
    # XXX: should validate that sdesc doesn't contain ':', as that prefix is removed
    with open(fn) as f:
        c = f.read()

        line = 1

        while True:
            match = re.match(r'^#.*$|^(curr|prev|test|category|requires|external-source): [^"\n]*$|^sdesc: ".+"$|^ldesc: "(.|\n)+?"$', c, re.MULTILINE)

            if match:
                line = line + len(match.group().splitlines())
                c = c[match.end()+1:]
            else:
                logging.error("%s validation error at line %d" % (fn, line))
                return False

            if len(c) == 0:
                return True

#
#
#

def main():
    maintainers.add_maintainer_directories()
    maintainers.add_maintainer_packages()

    for arch in cygwin.ARCHES:
        for name in sorted(maintainers.Maintainer.keys()):
            m = maintainers.Maintainer.get(name)

            if email:
                handler = buffering_smtp_handler.BufferingSMTPHandler(
                    mailhost='allegra', #'localhost',
                    fromaddr='cygwin-no-reply@cygwin.com',
                    toaddrs=email + list(m.email),
                    subject="upset messages",
                    logging_format='%(message)s')
                logging.getLogger().addHandler(handler)

            scan(m, arch)

            if email:
                handler.close()
                logging.getLogger().removeHandler(handler)


#
#
#

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Move files from maintainer upload directories to release area')
    parser.add_argument('-v', '--verbose', action='count', dest = 'verbose', help='verbose output')
    parser.add_argument('-n', '--dry-run', action='store_true', dest = 'dryrun', help="don't do anything")
    parser.add_argument('--email', action='store', dest = 'email', nargs='?', const=cygwin.EMAILS, help='email output to maintainer and ADDRS (default: ' + cygwin.EMAILS + ')', metavar='ADDRS')
    (args) = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.INFO)

    logging.basicConfig(format=sys.argv[0]+': %(message)s')

    dryrun = args.dryrun

    if args.email:
        email = args.email.split(',')

    main()
