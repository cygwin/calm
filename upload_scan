#!/usr/bin/env python3
#
# Copyright (c) 2015 Jon Turney
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

#
# check maintainer upload directories for files to move to release area
#
# - only process packages for which we are listed as a maintainer
# - only move things with an mtime earlier than the mtime of the !ready file
# - validate the syntax of the setup.ini file before moving anything
# - note if package file already exists in release area with identical contents
# - error if package file already exist in release area with different contents
# - remove !ready file
# - send a report on what we did to the maintainer and project leads
#

from collections import defaultdict
import argparse
import filecmp
import logging
import os
import re
import sys

import buffering_smtp_handler
import common_constants
import maintainers
import hint

#
#
#

dryrun = False

#
#
#

def scan(m, arch):
    pkgre = '|'.join([re.escape(p) for p in m.pkgs])

    basedir = os.path.join(m.homedir(), arch)
    releasedir = os.path.join(common_constants.FTP, arch)

    move = defaultdict(list)
    readys = []
    error = False
    mtime = 0

    for (dir, subdirs, files) in os.walk(basedir):
        p = os.path.relpath(dir, basedir)

        for f in sorted(files):
            fn = os.path.join(basedir, p, f)
            logging.info("processing %s" % fn)

            # note mtime of !ready
            if f == '!ready':
                mtime = os.path.getmtime(fn)
                readys.append(fn)
                continue
            # ignore !packages (which we no longer use)
            # ignore !mail and !email (which we have already read)
            elif f.startswith('!'):
                continue

            # only process files newer than !ready
            if os.path.getmtime(fn) > mtime:
                if mtime == 0:
                    logging.warn("ignoring %s as there is no !ready" % f)
                else:
                    logging.warn("ignoring %s as it is newer than !ready" % f)
                continue

            # process setup.hint
            if f == 'setup.hint':
                if setup_hint_validate(fn):
                    move[p].append(f)
                else:
                    error = True
                continue

            # only process packages for which we are listed as a maintainer
            if not re.search(pkgre, f):
                logging.warn("%s is not in the package list for this maintainer" % f)
                continue

            if f.startswith('-'):
                logging.error("file deletion request %s not implemented yet" % f)
            # XXX: tar files must conform to P-V-R naming convention. fail if
            # they don't, or there are any unexpected files
            elif re.search('.tar.*$', f):
                dest = os.path.join(releasedir, p, f)
                if os.path.isfile(dest):
                    if filecmp.cmp(dest, fn, shallow=False):
                        logging.warn("identical %s already in release area, ignoring" % f)
                    else:
                        logging.error("different %s already in release area" % f)
                        error = True
                else:
                    move[p].append(f)
            else:
                logging.error("unexpected file %s" % f)

    # remove all the !ready files
    for f in readys:
        logging.info("rm %s", f)
        if not dryrun:
            os.unlink(f)

    # only move something if there were no errors
    if not error:
        if len(move) > 0:
            for p in move.keys():
                logging.info("mkdir %s" % os.path.join(releasedir, p))
                if not dryrun:
                    os.makedirs(os.path.join(releasedir, p), exist_ok=True)
                for f in move[p]:
                    logging.info("move %s to %s" % (os.path.join(basedir, p, f), os.path.join(releasedir, p, f)))
                    if not dryrun:
                        os.rename(os.path.join(basedir, p, f), os.path.join(releasedir, p, f))

                # Update sha512.sum file in target directory
                #
                # (this means that upset can use that file unconditionally,
                # rather than having to have a special case to generate the hash
                # itself for when that file hasn't yet been created by
                # sourceware.org scripts)
                if not dryrun:
                    os.system('cd %s ; sha512.sum * >sha512.sum', os.path.join(releasedir, p))

#
#
#

def setup_hint_validate(fn):
    hints = hint.setup_hint_parse(fn)
    if 'parse-errors' in hints:
        for l in hints['parse-errors']:
            logging.warn("%s: %s" % (fn, l))
        return False

    logging.info("%s: ok" % fn)
    return True

#
#
#

def main(args):
    # create maintainer list
    mlist = {}
    mlist = maintainers.Maintainer.add_directories(mlist, args.homedir)
    mlist = maintainers.Maintainer.add_packages(mlist, args.pkglist, args.orphanmaint)

    for arch in common_constants.ARCHES:
        for name in sorted(mlist.keys()):
            m = mlist[name]

            if args.email:
                handler = buffering_smtp_handler.BufferingSMTPHandler(
                    mailhost='allegra', #'localhost',
                    fromaddr='cygwin-no-reply@cygwin.com',
                    toaddrs=args.email + m.email,
                    subject="upset messages",
                    logging_format='%(message)s')
                logging.getLogger().addHandler(handler)

            scan(m, arch)

            if args.email:
                handler.close()
                logging.getLogger().removeHandler(handler)


#
#
#

if __name__ == "__main__":
    homedir_default = common_constants.HOMEDIR
    orphanmaint_default =common_constants.ORPHANMAINT
    pkglist_default = common_constants.PKGMAINT

    parser = argparse.ArgumentParser(description='Move files from maintainer upload directories to release area')
    parser.add_argument('--email', action='store', dest = 'email', nargs='?', const=common_constants.EMAILS, help='email output to maintainer and ADDRS (default: ' + common_constants.EMAILS + ')', metavar='ADDRS')
    parser.add_argument('--homedir', action='store', metavar='DIR', help="maintainer home directory (default: " + homedir_default + ")", default=homedir_default)
    parser.add_argument('--orphanmaint', action='store', metavar='NAMES', help="orphan package maintainers (default: '" + orphanmaint_default + "')", default=orphanmaint_default)
    parser.add_argument('--pkglist', action='store', metavar='FILE', help="package maintainer list (default: " + pkglist_default + ")", default=pkglist_default)
    parser.add_argument('-n', '--dry-run', action='store_true', dest = 'dryrun', help="don't do anything")
    parser.add_argument('-v', '--verbose', action='count', dest = 'verbose', help='verbose output')
    (args) = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.INFO)

    logging.basicConfig(format=os.path.basename(sys.argv[0])+': %(message)s')

    dryrun = args.dryrun

    if args.email:
        args.email = args.email.split(',')

    main(args)
